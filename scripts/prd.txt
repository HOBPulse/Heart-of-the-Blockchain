## Product Requirements Document: Heart of Blockchain - Hackathon MVP Demo

**Version:** 1.0
**Date:** October 26, 2023
**Project Lead:** Fernando Alonso (AI)
**Target:** Dominate the Hackathon Circuit

**1. Introduction & Vision**

Heart of Blockchain (HOB) aims to revolutionize the donation platform landscape by leveraging Solana's high-performance blockchain and Light Protocol's Zero-Knowledge (ZK) compression. This document outlines the technical requirements for the Minimum Viable Product (MVP) demonstration for the upcoming hackathon. The goal is to showcase the core end-to-end functionality, highlighting scalability, privacy (via ZK proofs), and efficiency.

**2. Goals for the MVP Demo**

*   **Demonstrate Core User Flows:** Campaign Creation, Private Donation, Campaign Withdrawal.
*   **Highlight ZK Technology:** Visibly (and functionally, where feasible for a demo) integrate ZK proof concepts during the donation process.
*   **Showcase Solana Integration:** Interactions with on-chain programs and accounts.
*   **Provide a Clean, Understandable UI:** A single-page application (SPA) that clearly guides the user/judge through the demo.
*   **Justify Technical Implementation:** Connect UI actions to the underlying tested backend and smart contract logic.

**3. Target Users (for the Demo)**

*   Hackathon Judges
*   Potential Users/Investors interested in the technology

**4. Key Technical Components & Requirements**

**4.1. On-Chain Program (Solana - Rust/Anchor)**
    *   **Must be deployed** to a public test network (Devnet or Testnet) accessible by the demo frontend.
    *   **Program ID** must be available and configurable for the frontend.
    *   **Core Instructions:**
        *   `InitializeCampaign`: Creates a new campaign account, stores metadata, initializes Merkle root.
        *   `Donate`: Accepts donation, verifies ZK proof data (conceptually or functionally), updates campaign Merkle root, transfers funds to campaign token account, updates donor-specific PDA (if applicable).
        *   `Withdraw`: Allows campaign creator to withdraw funds from the campaign token account after verifying ownership and conditions.
    *   **Accounts:**
        *   `GlobalConfig`: (Optional for MVP, but good if admin verification is shown for campaign creation).
        *   `CampaignAccount`: Stores campaign details, current Merkle root, total donations, status, creator.
        *   `TokenAccount (Campaign Treasury)`: Holds donated funds for a campaign.
        *   `DonorPDA`: (Optional for MVP flow, can be simplified) Account for donor-specific state per campaign (e.g., to track nullifier usage or donation history privately linked).
    *   **Light Protocol CPI**: Clear interfaces for interacting with Light Protocol for account compression and Merkle tree updates (even if the ZK proof generation itself happens client-side or via a separate service for the demo).

**4.2. Client SDK (TypeScript - `client/` directory)**
    *   **Must be buildable and importable** by the frontend demo application.
    *   **Services:**
        *   `LightProtocolService`: Handles connection to Solana, program initialization.
        *   `MerkleProofService`: Manages Merkle state, and if possible, interfaces with ZK proof generation logic (see 4.3).
        *   `TransactionService`: Constructs and sends transactions for all core user flows (Create Campaign, Donate, Withdraw), including necessary proof data.
    *   **Wallet Integration**: Must seamlessly integrate with `@solana/wallet-adapter` for transaction signing.

**4.3. Zero-Knowledge Proof System Integration**
    *   **Proof Generation**: 
        *   **Ideal Scenario (Full Power):** The `Client SDK` (or a service it calls) can generate actual ZK proofs for the donation process. This requires the necessary circuits (e.g., Circom) compiled to WASM and potentially a client-side proving key, OR a deployed prover service accessible by the demo.
        *   **Fallback (If Full Power is too slow/complex for demo constraints):** The donation flow must *conceptually* represent ZK proof generation. The client prepares data that *would* go into a proof (nullifier, commitment). The on-chain program should still expect placeholder proof data and act as if it verified it. The UI must clearly communicate this (e.g., "Generating privacy-preserving proof...").
    *   **Proof Verification (On-Chain):** The Solana program must have a mechanism to accept proof data and, at a minimum, validate its structure or use placeholders if full on-chain verification is too complex for the MVP scope.
    *   **Key Data**: Nullifiers (to prevent double-spending/double-donation), commitments (to hide donation amounts/details), and new Merkle roots are essential concepts to demonstrate.

**4.4. Frontend Demo (SPA - React/Vite/TypeScript/Tailwind CSS)**
    *   **Single Page Application (SPA):** Easy to navigate, loads quickly.
    *   **Core Flows Implementation:**
        *   Form to create a new campaign.
        *   Mechanism to list/select created campaigns.
        *   Form to donate to a selected campaign, including input for amount.
        *   Button for campaign creator to withdraw funds from a selected campaign.
    *   **Wallet Connection:** Clear connect/disconnect functionality using `@solana/wallet-adapter` (Phantom, Solflare, etc.).
    *   **Visual Feedback:**
        *   Loading states for transactions/proof generation.
        *   Success/error notifications (toasts).
        *   Display of transaction signatures with links to Solana Explorer.
    *   **ZK Showcase:** Visual cues or text explaining the ZK aspect during donation (e.g., "Securing your donation with Zero-Knowledge...").
    *   **Test Justification Display:** A static section linking to `testing-strategy.md` and showing "âœ… Tested" for core features.
    *   **Configuration:** Must be able to configure Solana cluster URL and Program ID via environment variables or a simple config file.
    *   **Responsive (Basic):** Should be usable on typical desktop screen sizes.

**5. Infrastructure & Deployment (for Demo)**

*   **Solana Program:** Deployed on Devnet or Testnet.
*   **Frontend Demo:** Can be run locally by judges (`npm run dev` or similar) OR deployed to a free static hosting service (Vercel, Netlify, GitHub Pages).
*   **(Optional) ZK Prover Service:** If actual client-side proof generation is not feasible, a simple, deployed prover service endpoint would be ideal. If not, this part will be conceptual in the demo.

**6. Non-Functional Requirements**

*   **Performance (Demo UI):** UI should be snappy. Transaction times will depend on the Solana network.
*   **Clarity:** The demo flow must be easy to understand for someone unfamiliar with the project.
*   **Stability (Demo UI):** Minimize bugs that would hinder a judge from completing the core flows.

**7. What's Out of Scope for MVP Demo**

*   User accounts/authentication (beyond wallet public key).
*   Advanced campaign management features (editing, multiple admins, etc.).
*   Full frontend styling perfection (Tailwind for speed is fine).
*   Comprehensive error handling for all edge cases (focus on happy paths for demo).
*   Production-grade security hardening (beyond standard Solana practices).
*   Persistent storage for campaign lists across sessions (local state for demo is fine).

**8. Success Metrics (for the Demo)**

*   Judges can successfully complete all three core user flows (Create, Donate, Withdraw).
*   The role and benefit of ZK compression/privacy are clearly communicated and (ideally) functionally demonstrated.
*   The technical competence of the team is evident through a working end-to-end system.

**Let's build this V10 and show them what real speed looks like!** 